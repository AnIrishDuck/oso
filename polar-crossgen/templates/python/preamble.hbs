import dataclasses
import collections
import typing
from typing import get_type_hints
import json


class DeserializationError(Exception):
    pass


class SerializationError(Exception):
    pass

class Enum:
    def __getattribute__(self, attr):
        content = object.__getattribute__(self, "content")
        return content.__getattribute__(attr)

    def __str__(self):
        name = object.__getattribute__(self, "_name")
        return f"{name}({self.__str__()})"

    def __repr__(self):
        name = object.__getattribute__(self, "_name")
        return f"{name}({self.__repr__()})"

    def __eq__(self, other):
        return self.__eq__(other)



def make_special_method_wrapper(method_name):
    def wrapper(self, *args, **kwargs):
        return getattr(self, method_name)(*args, **kwargs)
    wrapper.__name__ = method_name
    return wrapper



def get_newtype_hints(obj_type):
    # hack to get the forward-evaluated version of a typing type
    def __types() -> obj_type: pass
    return get_type_hints(__types)["return"]

class TypedJsonDeserializer:
    """
    Deserializes JSON using the provided type


    JSON | Python
    ---------------
    object | dict
    array | list
    string | str
    number (int) | int
    number (real) | float
    true | True
    false | False
    null | None
    """

    input: typing.Any
    primitive_types = [str, int, float, bool]
    name: str = ""

    def __init__(self, input_val: typing.Any, name: str = ""):
        self.input = input_val
        self.name = name

    def deserialize_any(self, obj_type) -> typing.Any:
        if obj_type in self.primitive_types:
            return obj_type(self.input)
        elif hasattr(obj_type, "__origin__"):  # Generic type
            types = getattr(obj_type, "__args__")
            if getattr(obj_type, "__origin__") == collections.abc.Sequence:  # Sequence
                assert len(types) == 1
                item_type = types[0]
                assert isinstance(self.input, list)
                result = []
                for item in self.input:
                    result.append(
                        TypedJsonDeserializer(item).deserialize_any(item_type)
                    )

                return result

            elif getattr(obj_type, "__origin__") == tuple:  # Tuple
                result = []
                assert isinstance(self.input, list)
                assert len(types) == len(self.input)
                for (item_type, item) in zip(types, self.input):
                    item = TypedJsonDeserializer(item).deserialize_any(item_type)
                    result.append(item)
                return obj_type(result)

            elif getattr(obj_type, "__origin__") == typing.Union:  # Option or enum variant
                if len(types) == 2 and isinstance(types[1], type) and isinstance(None, types[1]): # Option
                    if self.input is None:
                        return None
                    else:
                        return self.deserialize_any(types[0])
            elif getattr(obj_type, "__origin__") == dict:  # Map
                assert len(types) == 2
                result_dict = dict()
                input_dict = self.input or {}
                assert isinstance(input_dict, dict)
                for k, v in input_dict.items():
                    result_dict[k] = TypedJsonDeserializer(v).deserialize_any(types[1])

                return result_dict

            else:
                raise DeserializationError("Unexpected type", obj_type)

        else:
            # handle enums + structs
                
            types = get_type_hints(obj_type)
            if dataclasses.is_dataclass(obj_type):
                fields = dataclasses.fields(obj_type)
                # regular struct
                kwargs = {
                    field.name: TypedJsonDeserializer(
                        self.input.get(field.name, None)
                    ).deserialize_any(types[field.name])
                    for field in fields
                }
                return obj_type(**kwargs)
            elif not isinstance(obj_type, type):
                # newtype
                ty = get_newtype_hints(obj_type.__supertype__)
                return obj_type(self.deserialize_any(ty))
            elif issubclass(obj_type, Enum):
                # enum
                assert (
                    len(self.input) == 1
                ), "deserializing an enum variant should only have one k: v pair"
                variant_name, variant_value = next(iter(self.input.items()))
                type_name = obj_type._name + variant_name
                for t in types["content"].__args__:
                    if t.__name__ == type_name:
                        return obj_type(tag=variant_name, content=TypedJsonDeserializer(
                            variant_value
                        ).deserialize_any(t))
                raise DeserializationError(f"unexpected variant for {obj_type}", variant_name)
            else:
                # type is a struct, but not a dataclass
                # no idea how to handle
                raise DeserializationError("Unexpected type", obj_type)


class TypedJsonSerializer:
    """
    Serializes JSON using the provided type


    JSON | Python
    ---------------
    object | dict
    array | list
    string | str
    number (int) | int
    number (real) | float
    true | True
    false | False
    null | None
    """

    input: typing.Any
    primitive_types = [str, int, float, bool]
    name: str = ""

    def __init__(self, input_val: typing.Any, name: str = ""):
        self.input = input_val
        self.name = name

    def serialize_any(self, obj_type) -> typing.Any:
        if obj_type in self.primitive_types:
            return obj_type(self.input)
        elif hasattr(obj_type, "__origin__"):  # Generic type
            types = getattr(obj_type, "__args__")
            if getattr(obj_type, "__origin__") == collections.abc.Sequence:  # Sequence
                assert len(types) == 1
                item_type = types[0]
                assert isinstance(self.input, list)
                result = []
                for item in self.input:
                    result.append(
                        TypedJsonSerializer(item).serialize_any(item_type)
                    )

                return result

            elif getattr(obj_type, "__origin__") == tuple:  # Tuple
                result = []
                assert len(types) == len(self.input)
                for (item_type, item) in zip(types, self.input):
                    item = TypedJsonSerializer(item).serialize_any(item_type)
                    result.append(item)
                return obj_type(result)

            elif getattr(obj_type, "__origin__") == typing.Union:  # Option or enum variant
                if len(types) == 2 and isinstance(types[1], type) and isinstance(None, types[1]): # Option
                    if self.input is None:
                        return None
                    else:
                        return self.serialize_any(types[0])
            elif getattr(obj_type, "__origin__") == dict:  # Map
                assert len(types) == 2
                result_dict = dict()
                input_dict = self.input or {}
                assert isinstance(input_dict, dict)
                for k, v in input_dict.items():
                    result_dict[k] = TypedJsonSerializer(v).serialize_any(types[1])

                return result_dict

            else:
                raise SerializationError("Unexpected type", obj_type)

        else:
            # handle enums + structs
            types = get_type_hints(obj_type)
            if dataclasses.is_dataclass(obj_type):
                fields = dataclasses.fields(obj_type)
                # regular struct
                kwargs = {
                    field.name: TypedJsonSerializer(
                        getattr(self.input, field.name, None)
                    ).serialize_any(types[field.name])
                    for field in fields
                }
                return kwargs
            elif not isinstance(obj_type, type):
                # newtype
                ty = get_newtype_hints(obj_type.__supertype__)
                return self.serialize_any(ty)
            elif issubclass(obj_type, Enum):
                # enum
                content = object.__getattribute__(self.input, "content")
                tag = object.__getattribute__(self.input, "tag")
                type_name = obj_type._name + tag
                for t in types["content"].__args__:
                    if t.__name__ == type_name:
                        return {
                            tag: TypedJsonSerializer(content).serialize_any(t)
                        }
                raise SerializationError(f"unexpected variant for {obj_type}", content)
            else:
                # type is a struct, but not a dataclass
                # no idea how to handle
                raise SerializationError("Unexpected type", obj_type)


def deserialize_json(input_str, obj):
    deserializer = TypedJsonDeserializer(json.loads(input_str))
    return deserializer.deserialize_any(obj)

def serialize_json(input_val, obj):
    serializer = TypedJsonSerializer(input_val)
    output = serializer.serialize_any(obj)
    return json.dumps(output)


