import dataclasses
import collections
import typing
from typing import get_type_hints
import json


class DeserializationError(Exception):
    pass

class Enum:
    def __getattribute__(self, attr):
        content = object.__getattribute__(self, "content")
        return content.__getattribute__(attr)

    def __str__(self):
        name = object.__getattribute__(self, "_name")
        return f"{name}({self.__str__()})"

    def __repr__(self):
        name = object.__getattribute__(self, "_name")
        return f"{name}({self.__repr__()})"

    def __eq__(self, other):
        return self.__eq__(other)



def make_special_method_wrapper(method_name):
    def wrapper(self, *args, **kwargs):
        return getattr(self, method_name)(*args, **kwargs)
    wrapper.__name__ = method_name
    return wrapper



def get_newtype_hints(obj_type):
    # hack to get the forward-evaluated version of a typing type
    def __types() -> obj_type: return
    return get_type_hints(__types)["return"]

class TypedJsonDeserializer:
    """
    Deserializes JSON using the provided type


    JSON | Python
    ---------------
    object | dict
    array | list
    string | str
    number (int) | int
    number (real) | float
    true | True
    false | False
    null | None
    """

    input: any
    primitive_types = [str, int, float, bool]
    name: str = ""

    def __init__(self, input_val: any, name: str = ""):
        self.input = input_val
        self.name = name

    # noqa
    def deserialize_any(self, obj_type) -> typing.Any:
        if obj_type in self.primitive_types:
            return obj_type(self.input)
        elif hasattr(obj_type, "__origin__"):  # Generic type
            types = getattr(obj_type, "__args__")
            if getattr(obj_type, "__origin__") == collections.abc.Sequence:  # Sequence
                assert len(types) == 1
                item_type = types[0]
                assert isinstance(self.input, list)
                result = []
                for item in self.input:
                    result.append(
                        TypedJsonDeserializer(item).deserialize_any(item_type)
                    )

                return result

            elif getattr(obj_type, "__origin__") == tuple:  # Tuple
                result = []
                assert isinstance(self.input, list)
                assert len(types) == len(self.input)
                for (item_type, item) in zip(types, self.input):
                    item = TypedJsonDeserializer(item).deserialize_any(item_type)
                    result.append(item)
                return tuple(result)

            elif getattr(obj_type, "__origin__") == typing.Union:  # Option or enum variant
                if len(types) == 2 and isinstance(types[1], type) and isinstance(None, types[1]): # Option
                    if self.input is None:
                        return None
                    else:
                        return self.deserialize_any(types[0])
            elif getattr(obj_type, "__origin__") == dict:  # Map
                assert len(types) == 2
                result = dict()
                assert isinstance(self.input, dict)
                for k, v in self.input.items():
                    result[k] = TypedJsonDeserializer(v).deserialize_any(types[1])

                return result

            else:
                raise DeserializationError("Unexpected type", obj_type)

        else:
            # handle enums + structs
                
            types = get_type_hints(obj_type)
            if dataclasses.is_dataclass(obj_type):
                fields = dataclasses.fields(obj_type)
                # regular struct
                kwargs = {
                    field.name: TypedJsonDeserializer(
                        self.input.get(field.name, None)
                    ).deserialize_any(types[field.name])
                    for field in fields
                }
                return obj_type(**kwargs)
            elif issubclass(obj_type, Enum):
                # enum
                assert (
                    len(self.input) == 1
                ), "deserializing an enum variant should only have one k: v pair"
                variant_name, variant_value = next(iter(self.input.items()))
                type_name = obj_type._name + variant_name
                for t in types["content"].__args__:
                    if t.__name__ == type_name:
                        return obj_type(tag=variant_name, content=TypedJsonDeserializer(
                            variant_value
                        ).deserialize_any(get_newtype_hints(t.__supertype__)))
                raise DeserializationError(f"unexpected variant for {obj_type}", variant_name)
            else:
                # type is a struct, but not a dataclass
                # no idea how to handle
                raise DeserializationError("Unexpected type", obj_type)
                

def deserialize_json(input_str, obj):
    deserializer = TypedJsonDeserializer(json.loads(input_str))
    return deserializer.deserialize_any(obj)


